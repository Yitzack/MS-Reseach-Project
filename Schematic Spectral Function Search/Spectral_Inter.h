#include<fstream>
#include<cstdlib>
#include<cmath>
#ifndef SPECTRAL_INTER
#define SPECTRAL_INTER
using namespace std;

class Spectral_Inter{
	public:
		Spectral_Inter(long double[5][3], long double, bool);	//Constructor using [5][3] array, arbitrary Temp, and vacuum status
		Spectral_Inter(long double[15], long double, bool);		//Constructor using [15] array, arbitrary Temp, and vacuum status
		Spectral_Inter(long double[5][3], int, bool);			//Constructor using [5][3] array, one 5 predefined Temps, and vacuum status
		Spectral_Inter(long double[15], int, bool);			//Constructor using [15] array, one 5 predefined Temps, and vacuum status

		long double Spectral(long double s, long double P);	//return the spectral function sigma(s,P)

		pair<long double, long double> Spatial(long double z);			//return the spatial correlation function for z
		pair<long double, long double> Spatial_PInt(long double z, long double s);	//return the s-integrand of the spatial correlation function for z and s
		pair<long double, long double> Spatial_sInt(long double z, long double P);	//return the P-integrand of the spatial correlation function for z and P
		pair<long double, long double> Spatial_Lorentz(long double z);		//return the spatial correlation function for z using P=0 spectral function
		long double Spatial_LorentzInt(long double z, long double s);		//return the s-integrand of the spatial correlation function for z and s using spectral function P=0. No error as it is the spectral function times kernel

		pair<long double, long double> Euclidean(long double tau, long double P);			//return the Euclidean correlation function for tau and P and temprature of the spectral function specified at the construction
		pair<long double, long double> Euclidean(long double tau, long double P, long double T);	//return the Euclidean correlation function for tau and P and specified temprature

		void Print(ostream&);	//Print the parameters to ostream

		void Add(long double, int);		//Add to a parameter denoted by index [n=3i+j]
		void Add(long double, int, int);	//Add to a parameter denoted by index pair [i],[j]
		void Replace(long double, int);	//Replace a parameter outright by index [n=3i+j]
		void Replace(long double, int, int);	//Replace a parameter outright by index pair [i],[j]
		long double Read(int);			//Read a parameter denoted by index [n=3i+j]
		long double Read(int, int);		//Read a parameter denoted by index pair [i],[j]

		void Random(int, long double[2], long double[2], bool);	//Randomly alters the parameters at [i][1] and [i][2] according to specified distribution
	private:
		long double Parameters[5][3];	//Parmeters of spectral function
		long double Temp;		//Temprature of spectral function. Unalterable after construction
		bool Vacuum;			//Determines if the spectral function is vacuum, if so, is always P=0. Unalterable after construction
		long double Width(long double, long double);						//Width function of spectral function
		long double Q(long double P, long double Q0, long double QV, long double P0);	//Momentum dependece of quantity Q

		void Spatial_PInt(long double z, long double s, long double werri, long double wint, int erri);	//Evaluates the P-integrand of the spatial correlation function
		void Spatial_sInt(long double z, long double P, long double werri, long double wint, int erri);	//Evaluates the s-integrand of the spatial correlation function
		pair<long double, long double> Spatial_P0Int(long double z, long double P0);	//Evaluates the cutoff kernel at P0 for the spatial correlation function
		void Characterize(long double P, pair<long double, long double>& zero);	//Characterizes the spectral function returning the complex pole
		long double Error[96][36];		//Error of each subregion
		long double Intergral[96][36];	//Value of each subregion

		long double SpatialGeneralKernel(long double s, long double P, long double z);		//General spatial correlation kernel
		long double SpatialCutoffKernel(long double s, long double P0, long double z);		//Cutoff kernel for the spatial correlation function
		long double SpatialLorentzKernel(long double s, long double z);				//Spatial correlation kernel for Lorentz invariant spectral function
		long double EuclideanKernel(long double s, long double P, long double tau, long double T);	//P-dependent Euclidean corrrelation kernel

		void mergeSort(long double[], int, int);	//Its a merge sort, probably beats quick sort given partially sorted lists
		void Normal(int, long double[2], long double[2]);	//Stores a random Normal number of mu=parameter and sigma=.1 and falls within ranges given
		void Uniform(int, int, long double, long double);	//Stores a uniform random number in the parameter [i][j] and in the given range
		long double Uniform();					//Uniform distribution on (0,1)
		const long double Boundary[8] = {0.00865, 0.0267, 0.0491, 0.0985, .421, .802, 1.01, 4.85};	//Seed of extra boundaries around on-shell peak
};

//Extra add on to the std::pair<long double,long double> object from std::pair that implements error propagation for something with a value of first+/-second.
#ifndef PAIR_SUM 
#define PAIR_SUM
pair<long double,long double> operator+(pair<long double,long double> a, pair<long double,long double> b)
{
	return(pair<long double,long double>(a.first+b.first,sqrt(pow(a.second,2)+pow(b.second,2))));
}
pair<long double,long double> operator-(pair<long double,long double> a, pair<long double,long double> b)
{
	return(pair<long double,long double>(a.first-b.first,sqrt(pow(a.second,2)+pow(b.second,2))));
}
pair<long double,long double> operator/(pair<long double, long double> a, pair<long double, long double> b)
{
	return(pair<long double,long double>(a.first/b.first,sqrt(pow(a.second/b.first,2)+pow(a.first*b.second/pow(b.first,2),2))));
}
pair<long double,long double> operator/(pair<long double,long double> a, long double b)	//b has no error, must be constant of equation
{
	return(pair<long double,long double>(a.first/b,a.second/b));
}
ostream& operator<<(ostream& os, pair<long double,long double> a)	//Outputs a value with error according to the Mathematica plain text standard
{
	os << "Around[" << a.first << "," << a.second << "]";
	return(os);
}
#endif

Spectral_Inter::Spectral_Inter(long double Parm[5][3], long double T, bool Vac)
{
	for(int i = 0; i < 5; i++)
		for(int j = 0; j < 3; j++)
			Parameters[i][j] = Parm[i][j];
	
	Temp = T;
	Vacuum = Vac;

	for(int i = 0; i < 96; i++)
		for(int j = 0; j < 36; j++)
		{
			Error[i][j] = 0;
			Intergral[i][j] = 0;
		}
}

Spectral_Inter::Spectral_Inter(long double Parm[15], long double T, bool Vac)
{
	for(int i = 0; i < 15; i++)
		Parameters[i/3][i%3] = Parm[i];
	
	Temp = T;
	Vacuum = Vac;

	for(int i = 0; i < 96; i++)
		for(int j = 0; j < 36; j++)
		{
			Error[i][j] = 0;
			Intergral[i][j] = 0;
		}
}

Spectral_Inter::Spectral_Inter(long double Parm[5][3], int T, bool Vac)
{
	for(int i = 0; i < 5; i++)
		for(int j = 0; j < 3; j++)
			Parameters[i][j] = Parm[i][j];
	
	switch(T)
	{
		case 0:
			Temp = 0;
			break;
		case 1:
			Temp = .194;
			break;
		case 2:
			Temp = .258;
			break;
		case 3:
			Temp = .320;
			break;
		case 4:
			Temp = .400;
			break;
	}

	Vacuum = Vac;

	for(int i = 0; i < 96; i++)
		for(int j = 0; j < 36; j++)
		{
			Error[i][j] = 0;
			Intergral[i][j] = 0;
		}
}

Spectral_Inter::Spectral_Inter(long double Parm[15], int T, bool Vac)
{
	for(int i = 0; i < 15; i++)
		Parameters[i/3][i%3] = Parm[i];
	
	switch(T)
	{
		case 0:
			Temp = 0;
			break;
		case 1:
			Temp = .194;
			break;
		case 2:
			Temp = .258;
			break;
		case 3:
			Temp = .320;
			break;
		case 4:
			Temp = .400;
			break;
	}

	Vacuum = Vac;

	for(int i = 0; i < 96; i++)
		for(int j = 0; j < 36; j++)
		{
			Error[i][j] = 0;
			Intergral[i][j] = 0;
		}
}

long double Spectral_Inter::Spectral(long double s, long double P)
{
	if(Vacuum)
		P = 0;

	static long double old_P = P;	//Static varibles are global between instances of the same class, careful
	static Spectral_Inter* old_this = this;
	if(0 == Q(P,Parameters[0][0],Parameters[0][1],Parameters[0][2]))
		return(0);
	static long double M = Q(P,Parameters[1][0],Parameters[1][1],Parameters[1][2]);
	static long double A = 2.*M*Q(P,Parameters[0][0],Parameters[0][1],Parameters[0][2]);
	long double Gamma = Q(P,Parameters[2][0],Parameters[2][1],Parameters[2][2])*Width(sqrt(s),P);

	if(P != old_P || old_this != this)	//Don't re-evaluate parameters unless P or 'this' has changed since last call. P will always change after parameter change.
	{
		old_P = P;
		old_this = this;
		M = Q(P,Parameters[1][0],Parameters[1][1],Parameters[1][2]);
		A = 2.*M*Q(P,Parameters[0][0],Parameters[0][1],Parameters[0][2]);
	}

	return((A*Gamma*M*sqrt((s+pow(P,2))/(pow(M,2)+pow(P,2))))/(M_PI*(pow(s-pow(M,2),2)+pow(Gamma*M*sqrt((s+pow(P,2))/(pow(M,2)+pow(P,2))),2))));
}

long double Spectral_Inter::Width(long double E, long double P)
{
	if(Vacuum)
		P = 0;

	static long double old_P = P;
	static Spectral_Inter* old_this = this;
	static long double M = Q(P,Parameters[1][0],Parameters[1][1],Parameters[1][2]);
	static long double a = Q(P,Parameters[3][0],Parameters[3][1],Parameters[3][2]);
	static long double b = Q(P,Parameters[4][0],Parameters[4][1],Parameters[4][2]);
	static long double E0 = M-2.*Q(P,Parameters[2][0],Parameters[2][1],Parameters[2][2]);

	if(P != old_P || old_this != this)	//Don't re-evaluate parameters unless P or 'this' has changed since last call. P will always change after parameter change.
	{
		old_P = P;
		old_this = this;
		M = Q(P,Parameters[1][0],Parameters[1][1],Parameters[1][2]);
		a = Q(P,Parameters[3][0],Parameters[3][1],Parameters[3][2]);
		b = Q(P,Parameters[4][0],Parameters[4][1],Parameters[4][2]);
		E0 = M-2.*Q(P,Parameters[2][0],Parameters[2][1],Parameters[2][2]);
	}

	return(exp(a*(sqrt(pow(sqrt(pow(E,2)+pow(P,2))-sqrt(pow(E0,2)+pow(P,2)),2)+pow(b,2))-sqrt(pow(E,2)+pow(P,2))+sqrt(pow(E0,2)+pow(P,2)))/(2.*(sqrt(pow(sqrt(pow(M,2)+pow(P,2))-sqrt(pow(E0,2)+pow(P,2)),2)+pow(b,2))-sqrt(pow(M,2)+pow(P,2))+sqrt(pow(E0,2)+pow(P,2))))*(M-E0-sqrt(pow(M-E0,2)+pow(b,2)))+a/2.*(E0-M+sqrt(pow(b,2)+pow(M-E0,2)))));
}

long double Spectral_Inter::Q(long double P, long double Q0, long double QV, long double P0)
{
	return((Q0*pow(P0,2)+QV*pow(P,2))/(pow(P0,2)+pow(P,2)));
}

pair<long double, long double> Spectral_Inter::Spatial(long double z)
{
#if ORDER == 16
	long double Disp[] = {0.27963041316178319341346652274898, 0.53846931010568309103631442070021, 0.75416672657084922044081716694612, 0.90617984593866399279762687829939, 0.98408536009484246449617293463614};	//Displacement from center for 16th order Gauss-Kronrod integration from Mathematica
	long double w[] = {0.28298741785749121320425560137111, 0.272849801912558922340993264484456, 0.24104033922864758669994261122326, 0.186800796556492657467800026878486, 0.115233316622473394024626845880574, 0.0425820367510818328645094508476701};	//Weight of the function at Disp
	long double werr[] = {0.272849801912558922340993264484456, -0.28590147103139767568463328751778, 0.272849801912558922340993264484456, -0.237588331270718881341348903612376, 0.186800796556492657467800026878486, -0.121693568433715693489637194839344, 0.0425820367510818328645094508476701};	//Weight of the error estimate function at Disp
#elif ORDER == 37
	long double Disp[] = {0.12523340851146891547244136946385, 0.24850574832046927626779096036272, 0.36783149899818019375269153664372, 0.48133945047815709293594361501883, 0.58731795428661744729670241894053, 0.68405989547005589394492910034115, 0.76990267419430468703689383321282, 0.84355812416115324479214188505984, 0.90411725637047485667846586611910, 0.95053779594312129654906019513162, 0.98156063424671925069054909014928, 0.99693392252959542691235023725839};	//Displacement from center for 37th order Gauss-Kronrod integration
	long double w[] = {0.125556893905474335304296132860078, 0.12458416453615607343731247320923, 0.121626303523948383246099758091310, 0.11671205350175682629358074530573, 0.110022604977644072635907398742250, 0.101649732279060277715688770491228, 0.0915494682950492105281719397396142, 0.079920275333601701493392609529783, 0.0672509070508399303049409400473161, 0.053697017607756251228889163320458, 0.0389152304692994771150896322858629, 0.023036084038982232591084580367969, 0.00825771143316839575769392243921158};	//Weights for 37th order Gauss-Kronrod integration
	long double werr[] = {0.125556893905474335304296132860078, -0.12456288127724671156324996283372, 0.121626303523948383246099758091310, -0.116780483036597982467269153619148, 0.110022604977644072635907398742250, -0.101517694444005644033375685318571, 0.0915494682950492105281719397396142, -0.080158053209744524841259920013576, 0.0672509070508399303049409400473161, -0.053242308387562179731365554873538, 0.0389152304692994771150896322858629, -0.0241392523475295946035313811170481, 0.00825771143316839575769392243921158};	//Error weights for 37th order Gauss-Kronrod integration
#elif ORDER == 64
	long double Disp[] = {0.07296724759579058908806031209955, 0.14556185416089509093703098233869, 0.21738009387172883298179561608565, 0.28802131680240109660079251606460, 0.35712525365992107730319197431219, 0.42434212020743878357366888854379, 0.48929590889566864140105140228151, 0.55161883588721980705901879672431, 0.61099712378976603905186076209981, 0.66713880419741231930596666999034, 0.71972345257202475786195418640521, 0.76843996347567790861587785130623, 0.81305258084753191324907332122919, 0.85336336458331728364725063858757, 0.88912831533118433426270707847375, 0.92009933415040082879018713371497, 0.94614721677851262706535437885119, 0.96722683856630629431662221490770, 0.98318486356168595383392464989066, 0.99375217062038950026024203593794, 0.99896193068731718686198704308270};	//Displacement from center for 64th order Gauss-Kronrod integration
	long double w[] = {0.07302748796276908297314068625699, 0.0728456528305084410294911786777899, 0.072275482222034062651328264004603, 0.0712933463637845561021040045941832, 0.069929765008398753379866909680647, 0.0682207062610252150704081432085748, 0.066149577815951110013778554529288, 0.0636956152491007998422517557993921, 0.060898680204661962686034547272808, 0.0578104574976095223026959977828257, 0.054418675178383649262446811973774, 0.0506971977965175119748827957014245, 0.046697324731514497924831858406713, 0.0424969328811184855040644730480614, 0.038083153453465002583875378860838, 0.0334025463208076220711022803409528, 0.028518426570204953082884284481435, 0.0235741990830290305646428964274167, 0.018560055408876216262191994606715, 0.0133046426070883174480910406380580, 0.0078183373021241792478434900552220, 0.00279548123241156950861299678078312};	//Weights for 64th order Gauss-Kronrod integration
	long double werr[] = {-0.073053645686921344218844461426381, 0.0728456528305084410294911786777899, -0.072248921767935996412498902549150, 0.0712933463637845561021040045941832, -0.069957629782674401342266514186936, 0.0682207062610252150704081432085748, -0.066119360817386351767274019967487, 0.0636956152491007998422517557993921, -0.060932735849066571509332629852926, 0.0578104574976095223026959977828257, -0.054378623988764728401027766096332, 0.0506971977965175119748827957014245, -0.0467470987245193636284578827072191, 0.0424969328811184855040644730480614, -0.0380169601749142994331762744393456, 0.0334025463208076220711022803409528, -0.0286159988566522552007515419910130, 0.0235741990830290305646428964274167, -0.0183937343619762775377586736926149, 0.0133046426070883174480910406380580, -0.0081988909556501540763811268032490, 0.00279548123241156950861299678078312};	//Error weights for 64th order Gauss-Kronrod integration*/
#elif ORDER == 97
	long double Disp[] = {0.04830766568773831623481257044050, 0.09650269687689436580083125301636, 0.14447196158279649348518637359881, 0.19210360898314249727164159225259, 0.23928736225213707454460320916550, 0.28591245858945975941660710119035, 0.33186860228212764977991680573019, 0.37704942115412110544533548554981, 0.42135127613063534536411943617243, 0.46466930848199221775617820037971, 0.50689990893222939002374747437782, 0.54794631419915247868093950160974, 0.58771575724076232904074547640183, 0.62611293770182399782023837975795, 0.66304426693021520097511516866324, 0.69842655779521049288477014244748, 0.73218211874028968038742666509127, 0.76422825199780370415066012687437, 0.79448379596794240696309729897043, 0.82288295013605132164826884947213, 0.84936761373256997013369300496774, 0.87386976894531060612966180261363, 0.89632115576605212396530724371921, 0.91667726665136432427534565885792, 0.93490607593773968917091913483541, 0.95095468484866118538988275061533, 0.96476225558750643077381192811827, 0.97631028361466380719766964319312, 0.98561151154526833540017504463090, 0.99262803526297191268579115643847, 0.99726386184948156354498112866504, 0.99954590212436447863561028016112};	//Displacement from center for 97th order Gauss-Kronrod integration
	long double w[] = {0.0483263839865677583754454340005196, 0.04827019307577738559871207883299, 0.0481009691854577469278465438391581, 0.047818908736988472212263584657302, 0.0474260618738823823628799498539221, 0.046922968281703611103480713352515, 0.0463087567380257132403812984724432, 0.045585826564547070280575461963265, 0.0447586387497669372951991920753785, 0.043827544030139749046816152673798, 0.0427911155964467469336549254437386, 0.041654019985643051398296413297779, 0.0404234923703730966723492694215763, 0.039099420133306611207482127044236, 0.0376791306456133985148959737488490, 0.036169769475642299860958391303290, 0.0345821227447330341307263834168846, 0.032915077643903600263296476785556, 0.0311633255619737371711558486849664, 0.029336956689620661368615614585584, 0.0274520984222104037831477067959546, 0.025505695480894652814528899899308, 0.0234866596721633245920879128647720, 0.021408913184821915955777518020231, 0.0192987714303268112944037397635239, 0.017149805209784253256085826220233, 0.0149361036060860273850967513325094, 0.012676054806654402859368883399502, 0.0104239873988068188280342507620158, 0.0081725040385316684143438051192845, 0.00584173707916669330394797663999954, 0.0034268187757723709355745755785249, 0.00122336081795147180029303715064886};	//Weights for 97th order Gauss-Kronrod integration
	long double werr[] = {0.0483263839865677583754454340005196, -0.04826989543895041496805275123058, 0.0481009691854577469278465438391581, -0.047819811342286387206818417546829, 0.0474260618738823823628799498539221, -0.046921430799100954535699524315602, 0.0463087567380257132403812984724432, -0.045588052131216814432293115148372, 0.0447586387497669372951991920753785, -0.043824548974264062095955310078004, 0.0427911155964467469336549254437386, -0.041657904241303703823902661306570, 0.0404234923703730966723492694215763, -0.039094475653763695264258791784071, 0.0376791306456133985148959737488490, -0.036176024633206206364440965175198, 0.0345821227447330341307263834168846, -0.032907145132458246574353586921383, 0.0311633255619737371711558486849664, -0.029347136788914885776668022714587, 0.0274520984222104037831477067959546, -0.025492363781481523381634344790214, 0.0234866596721633245920879128647720, -0.0214269848374047647011011285858944, 0.0192987714303268112944037397635239, -0.0171240577032371798466019060321402, 0.0149361036060860273850967513325094, -0.0127160105026076565963837063897218, 0.0104239873988068188280342507620158, -0.0081018906923740021908267570871021, 0.00584173707916669330394797663999954, -0.0035917912336977256648324881603283, 0.00122336081795147180029303715064886};	//Error weights for 97th order Gauss-Kronrod integration
#endif
	long double x1, x2;	//Abscissa
	long double a, b;	//Sub-interval limits of integration
#ifdef Ps
	long double Max = 552.25;	//Upper limit of integration
#endif
#ifdef sP
	long double Max = 187.*M_PI/(2.*z);	//Upper limit of integration
#endif
	pair<long double, long double> holder;
#ifdef Ps
	long double Stops[36] = {0, 1, 3, 6, 9, 12, 15, 18, 21, 24, 34, 44, 54, 104, 204, 304, 404, 504, 552.25};	//Default subintervals
#endif
#ifdef sP
	long double Intervals = M_PI/z;	//Default subinterval spacing
#endif
	int i, j;		//Counting varibles

	if(Parameters[0][0]==0 && Parameters[0][1]==0)	//If the amplitude the spectral function is zero for all P, then the answer is zero. Shortcut answer
		return(pair<long double, long double>(0,0));

#ifdef Ps
	Stops[19] = Parameters[1][0];							//Stop at M_J/Psi(P=0)
	Stops[29] = Q(5, Parameters[1][0], Parameters[1][1], Parameters[1][2]);	//Stop at M_J/Psi(P=5)
	Stops[35] = Parameters[1][1];							//Stop at M_J/Psi(P=infty)
	for(i = 1; i < 10; i++)
		Stops[i+19] = pow(Stops[19]*(long double)(10-i)/10.+Stops[29]*(long double)(i)/10.,2);	//divide the first interval 10 ways
	for(i = 1; i < 5; i++)
		Stops[i+29] = pow(Stops[29]*(long double)(6-i)/6.+Stops[35]*(long double)(i)/6.,2);	//divide the second interval 5 ways

	mergeSort(Stops, 0, 35);	//sort the list of subintervals

	a = 0;
	b = Stops[1];		//First subinterval
#endif
#ifdef sP
	a = 0;
	b = M_PI/(2.*z);	//First subinterval
#endif
	i = 2;
	do
	{
		if(b > Max)
			b = Max;	//Don't exceed specified maximum of the total interval

#if ORDER == 16
		for(j = 0; j < 5; j++) //Integrate the sub-interval
#elif ORDER == 37
		for(j = 0; j < 12; j++)
#elif ORDER == 64
		for(j = 0; j < 21; j++)
#elif ORDER == 97
		for(j = 0; j < 32; j++)
#endif
		{
			x1 = (b+a-Disp[j]*(b-a))/2.;
			x2 = (b+a+Disp[j]*(b-a))/2.;

#ifdef Ps
			Spatial_PInt(z, x1, werr[j+1]*(b-a)/2., w[j+1]*(b-a)/2., i-2);
			Spatial_PInt(z, x2, werr[j+1]*(b-a)/2., w[j+1]*(b-a)/2., i-2);
#endif
#ifdef sP
			Spatial_sInt(z, x1, werr[j+1]*(b-a)/2., w[j+1]*(b-a)/2., i-2);
			Spatial_sInt(z, x2, werr[j+1]*(b-a)/2., w[j+1]*(b-a)/2., i-2);
#endif
		}
#ifdef Ps
		Spatial_PInt(z, a/2.+b/2., werr[0]*(b-a)/2., w[0]*(b-a)/2., i-2);
#endif
#ifdef sP
		Spatial_sInt(z, a/2.+b/2., werr[0]*(b-a)/2., w[0]*(b-a)/2., i-2);
#endif
		a = b;
#ifdef Ps
		b = Stops[i];	//Step through subintervals
#endif
#ifdef sP
		b += Intervals;
		if(b>1&&a<1) Intervals = M_PI/z;	//Step through subintervals
#endif
		i++;
	}while(a < Max);

	long double Int_acculmate = 0;	//Accumalate the total integral and error
	long double Err_acculmate = 0;
	for(i = 0; i < 96; i++)
		for(j = 0; j < 36; j++)
		{
			Int_acculmate += Intergral[i][j];
			Err_acculmate += abs(Error[i][j]);	//Error is total of the absolute error for each subregion
			Error[i][j] = 0;			//Reset the global arrays for next use
			Intergral[i][j] = 0;
		}

#ifdef sP
	holder = Spatial_P0Int(z, Max);	//Evaluate the cutoff
#endif
#ifdef Ps
	holder = pair<long double, long double>(0,0);	//No cutoff in this order, but I need something for the next line to work
#endif

	return(pair<long double, long double>(Int_acculmate,Err_acculmate)+holder);
}

pair<long double, long double> Spectral_Inter::Spatial_PInt(long double z, long double s)
{
	pair<long double, long double> holder = pair<long double, long double> (0,0);
	Spatial_PInt(z, s, 1, 1, 0);	//Evaluate the P-integral for s with weight of 1, error weight of 1, and store to column 0
	for(int i = 0; i < 96; i++)	//Collect the results to be returned
	{
		holder.first += Intergral[i][0];
		holder.second += abs(Error[i][0]);
		Error[i][0] = 0;
		Intergral[i][0] = 0;
	}
	return(holder);
}

pair<long double, long double> Spectral_Inter::Spatial_sInt(long double z, long double P)
{
	pair<long double, long double> holder = pair<long double, long double> (0,0);
	Spatial_sInt(z, P, 1, 1, 0);	//Evaluate the s-integral for P with weight of 1, error weight of 1, and store to row 0
	for(int i = 0; i < 36; i++)	//Collect the results to be returned
	{
		holder.first += Intergral[0][i];
		holder.second += Error[0][i];
		Error[0][i] = 0;
		Intergral[0][i] = 0;
	}
	return(holder);
}

long double Spectral_Inter::Spatial_LorentzInt(long double z, long double s)
{
	if(s == 0)
		return(0);
	return(SpatialLorentzKernel(s, z)*Spectral(s, 0));
}

void Spectral_Inter::Spatial_PInt(long double z, long double s, long double werri, long double wint, int erri)
{
#if ORDER == 16
	long double Disp[] = {0.27963041316178319341346652274898, 0.53846931010568309103631442070021, 0.75416672657084922044081716694612, 0.90617984593866399279762687829939, 0.98408536009484246449617293463614};	//Displacement from center for 16th order Gauss-Kronrod integration from Mathematica
	long double w[] = {0.28298741785749121320425560137111, 0.272849801912558922340993264484456, 0.24104033922864758669994261122326, 0.186800796556492657467800026878486, 0.115233316622473394024626845880574, 0.0425820367510818328645094508476701};	//Weight of the function at Disp
	long double werr[] = {0.272849801912558922340993264484456, -0.28590147103139767568463328751778, 0.272849801912558922340993264484456, -0.237588331270718881341348903612376, 0.186800796556492657467800026878486, -0.121693568433715693489637194839344, 0.0425820367510818328645094508476701};	//Weight of the error estimate function at Disp
#elif ORDER == 37
	long double Disp[] = {0.12523340851146891547244136946385, 0.24850574832046927626779096036272, 0.36783149899818019375269153664372, 0.48133945047815709293594361501883, 0.58731795428661744729670241894053, 0.68405989547005589394492910034115, 0.76990267419430468703689383321282, 0.84355812416115324479214188505984, 0.90411725637047485667846586611910, 0.95053779594312129654906019513162, 0.98156063424671925069054909014928, 0.99693392252959542691235023725839};	//Displacement from center for 37th order Gauss-Kronrod integration
	long double w[] = {0.125556893905474335304296132860078, 0.12458416453615607343731247320923, 0.121626303523948383246099758091310, 0.11671205350175682629358074530573, 0.110022604977644072635907398742250, 0.101649732279060277715688770491228, 0.0915494682950492105281719397396142, 0.079920275333601701493392609529783, 0.0672509070508399303049409400473161, 0.053697017607756251228889163320458, 0.0389152304692994771150896322858629, 0.023036084038982232591084580367969, 0.00825771143316839575769392243921158};	//Weights for 37th order Gauss-Kronrod integration
	long double werr[] = {0.125556893905474335304296132860078, -0.12456288127724671156324996283372, 0.121626303523948383246099758091310, -0.116780483036597982467269153619148, 0.110022604977644072635907398742250, -0.101517694444005644033375685318571, 0.0915494682950492105281719397396142, -0.080158053209744524841259920013576, 0.0672509070508399303049409400473161, -0.053242308387562179731365554873538, 0.0389152304692994771150896322858629, -0.0241392523475295946035313811170481, 0.00825771143316839575769392243921158};	//Error weights for 37th order Gauss-Kronrod integration
#elif ORDER == 64
	long double Disp[] = {0.07296724759579058908806031209955, 0.14556185416089509093703098233869, 0.21738009387172883298179561608565, 0.28802131680240109660079251606460, 0.35712525365992107730319197431219, 0.42434212020743878357366888854379, 0.48929590889566864140105140228151, 0.55161883588721980705901879672431, 0.61099712378976603905186076209981, 0.66713880419741231930596666999034, 0.71972345257202475786195418640521, 0.76843996347567790861587785130623, 0.81305258084753191324907332122919, 0.85336336458331728364725063858757, 0.88912831533118433426270707847375, 0.92009933415040082879018713371497, 0.94614721677851262706535437885119, 0.96722683856630629431662221490770, 0.98318486356168595383392464989066, 0.99375217062038950026024203593794, 0.99896193068731718686198704308270};	//Displacement from center for 64th order Gauss-Kronrod integration
	long double w[] = {0.07302748796276908297314068625699, 0.0728456528305084410294911786777899, 0.072275482222034062651328264004603, 0.0712933463637845561021040045941832, 0.069929765008398753379866909680647, 0.0682207062610252150704081432085748, 0.066149577815951110013778554529288, 0.0636956152491007998422517557993921, 0.060898680204661962686034547272808, 0.0578104574976095223026959977828257, 0.054418675178383649262446811973774, 0.0506971977965175119748827957014245, 0.046697324731514497924831858406713, 0.0424969328811184855040644730480614, 0.038083153453465002583875378860838, 0.0334025463208076220711022803409528, 0.028518426570204953082884284481435, 0.0235741990830290305646428964274167, 0.018560055408876216262191994606715, 0.0133046426070883174480910406380580, 0.0078183373021241792478434900552220, 0.00279548123241156950861299678078312};	//Weights for 64th order Gauss-Kronrod integration
	long double werr[] = {-0.073053645686921344218844461426381, 0.0728456528305084410294911786777899, -0.072248921767935996412498902549150, 0.0712933463637845561021040045941832, -0.069957629782674401342266514186936, 0.0682207062610252150704081432085748, -0.066119360817386351767274019967487, 0.0636956152491007998422517557993921, -0.060932735849066571509332629852926, 0.0578104574976095223026959977828257, -0.054378623988764728401027766096332, 0.0506971977965175119748827957014245, -0.0467470987245193636284578827072191, 0.0424969328811184855040644730480614, -0.0380169601749142994331762744393456, 0.0334025463208076220711022803409528, -0.0286159988566522552007515419910130, 0.0235741990830290305646428964274167, -0.0183937343619762775377586736926149, 0.0133046426070883174480910406380580, -0.0081988909556501540763811268032490, 0.00279548123241156950861299678078312};	//Error weights for 64th order Gauss-Kronrod integration*/
#elif ORDER == 97
	long double Disp[] = {0.04830766568773831623481257044050, 0.09650269687689436580083125301636, 0.14447196158279649348518637359881, 0.19210360898314249727164159225259, 0.23928736225213707454460320916550, 0.28591245858945975941660710119035, 0.33186860228212764977991680573019, 0.37704942115412110544533548554981, 0.42135127613063534536411943617243, 0.46466930848199221775617820037971, 0.50689990893222939002374747437782, 0.54794631419915247868093950160974, 0.58771575724076232904074547640183, 0.62611293770182399782023837975795, 0.66304426693021520097511516866324, 0.69842655779521049288477014244748, 0.73218211874028968038742666509127, 0.76422825199780370415066012687437, 0.79448379596794240696309729897043, 0.82288295013605132164826884947213, 0.84936761373256997013369300496774, 0.87386976894531060612966180261363, 0.89632115576605212396530724371921, 0.91667726665136432427534565885792, 0.93490607593773968917091913483541, 0.95095468484866118538988275061533, 0.96476225558750643077381192811827, 0.97631028361466380719766964319312, 0.98561151154526833540017504463090, 0.99262803526297191268579115643847, 0.99726386184948156354498112866504, 0.99954590212436447863561028016112};	//Displacement from center for 97th order Gauss-Kronrod integration
	long double w[] = {0.0483263839865677583754454340005196, 0.04827019307577738559871207883299, 0.0481009691854577469278465438391581, 0.047818908736988472212263584657302, 0.0474260618738823823628799498539221, 0.046922968281703611103480713352515, 0.0463087567380257132403812984724432, 0.045585826564547070280575461963265, 0.0447586387497669372951991920753785, 0.043827544030139749046816152673798, 0.0427911155964467469336549254437386, 0.041654019985643051398296413297779, 0.0404234923703730966723492694215763, 0.039099420133306611207482127044236, 0.0376791306456133985148959737488490, 0.036169769475642299860958391303290, 0.0345821227447330341307263834168846, 0.032915077643903600263296476785556, 0.0311633255619737371711558486849664, 0.029336956689620661368615614585584, 0.0274520984222104037831477067959546, 0.025505695480894652814528899899308, 0.0234866596721633245920879128647720, 0.021408913184821915955777518020231, 0.0192987714303268112944037397635239, 0.017149805209784253256085826220233, 0.0149361036060860273850967513325094, 0.012676054806654402859368883399502, 0.0104239873988068188280342507620158, 0.0081725040385316684143438051192845, 0.00584173707916669330394797663999954, 0.0034268187757723709355745755785249, 0.00122336081795147180029303715064886};	//Weights for 97th order Gauss-Kronrod integration
	long double werr[] = {0.0483263839865677583754454340005196, -0.04826989543895041496805275123058, 0.0481009691854577469278465438391581, -0.047819811342286387206818417546829, 0.0474260618738823823628799498539221, -0.046921430799100954535699524315602, 0.0463087567380257132403812984724432, -0.045588052131216814432293115148372, 0.0447586387497669372951991920753785, -0.043824548974264062095955310078004, 0.0427911155964467469336549254437386, -0.041657904241303703823902661306570, 0.0404234923703730966723492694215763, -0.039094475653763695264258791784071, 0.0376791306456133985148959737488490, -0.036176024633206206364440965175198, 0.0345821227447330341307263834168846, -0.032907145132458246574353586921383, 0.0311633255619737371711558486849664, -0.029347136788914885776668022714587, 0.0274520984222104037831477067959546, -0.025492363781481523381634344790214, 0.0234866596721633245920879128647720, -0.0214269848374047647011011285858944, 0.0192987714303268112944037397635239, -0.0171240577032371798466019060321402, 0.0149361036060860273850967513325094, -0.0127160105026076565963837063897218, 0.0104239873988068188280342507620158, -0.0081018906923740021908267570871021, 0.00584173707916669330394797663999954, -0.0035917912336977256648324881603283, 0.00122336081795147180029303715064886};	//Error weights for 97th order Gauss-Kronrod integration
#endif
	long double a, b;				//Sub-interval limits of integration
	long double x1, x2;				//Abscissa
	long double Max = 187.*M_PI/(2.*z);		//Upper limit of integration
	long double holder;
	long double Intervals = M_PI/z;		//Sub-interval spacing
	int i, j;					//Counting varibles

	if(Parameters[0][0]==0 && Parameters[0][1]==0)
		return(pair<long double, long double>(0,0));

	a = 0;
	b = M_PI/(2.*z);
	i = 0;

	do
	{
		if(b > Max)
			b = Max;

#if ORDER == 16
		for(j = 0; j < 5; j++) //Integrate the sub-interval
#elif ORDER == 37
		for(j = 0; j < 12; j++)
#elif ORDER == 64
		for(j = 0; j < 21; j++)
#elif ORDER == 97
		for(j = 0; j < 32; j++)
#endif
		{
			x1 = (b+a-Disp[j]*(b-a))/2.;
			x2 = (b+a+Disp[j]*(b-a))/2.;

			holder = SpatialGeneralKernel(s, x1, z)*Spectral(s, x1);
			Intergral[i][erri] += w[j+1]*wint*holder*(b-a)/2.;	//Instead of storing the results of the sub-interval in local scope, store it in global array
			Error[i][erri] += werr[j+1]*werri*holder*(b-a)/2.;
			holder = SpatialGeneralKernel(s, x2, z)*Spectral(s, x2);
			Intergral[i][erri] += w[j+1]*wint*holder*(b-a)/2.;
			Error[i][erri] += werr[j+1]*werri*holder*(b-a)/2.;
		}
		holder = SpatialGeneralKernel(s, a/2.+b/2., z)*Spectral(s, a/2.+b/2.);
		Intergral[i][erri] += w[0]*wint*holder*(b-a)/2.;
		Error[i][erri] += werr[0]*werri*holder*(b-a)/2.;

		a = b;
		b += Intervals;
		i++;
	}while(a < Max);

	holder = SpatialCutoffKernel(s, a, z)*Spectral(s, a);
	Intergral[i][erri] += holder*wint;
	Error[i][erri] += holder*werri;

	return;
}

void Spectral_Inter::Spatial_sInt(long double z, long double P, long double werri, long double wint, int erri)
{
#if ORDER == 16
	long double Disp[] = {0.27963041316178319341346652274898, 0.53846931010568309103631442070021, 0.75416672657084922044081716694612, 0.90617984593866399279762687829939, 0.98408536009484246449617293463614};	//Displacement from center for 16th order Gauss-Kronrod integration from Mathematica
	long double w[] = {0.28298741785749121320425560137111, 0.272849801912558922340993264484456, 0.24104033922864758669994261122326, 0.186800796556492657467800026878486, 0.115233316622473394024626845880574, 0.0425820367510818328645094508476701};	//Weight of the function at Disp
	long double werr[] = {0.272849801912558922340993264484456, -0.28590147103139767568463328751778, 0.272849801912558922340993264484456, -0.237588331270718881341348903612376, 0.186800796556492657467800026878486, -0.121693568433715693489637194839344, 0.0425820367510818328645094508476701};	//Weight of the error estimate function at Disp
#elif ORDER == 37
	long double Disp[] = {0.12523340851146891547244136946385, 0.24850574832046927626779096036272, 0.36783149899818019375269153664372, 0.48133945047815709293594361501883, 0.58731795428661744729670241894053, 0.68405989547005589394492910034115, 0.76990267419430468703689383321282, 0.84355812416115324479214188505984, 0.90411725637047485667846586611910, 0.95053779594312129654906019513162, 0.98156063424671925069054909014928, 0.99693392252959542691235023725839};	//Displacement from center for 37th order Gauss-Kronrod integration
	long double w[] = {0.125556893905474335304296132860078, 0.12458416453615607343731247320923, 0.121626303523948383246099758091310, 0.11671205350175682629358074530573, 0.110022604977644072635907398742250, 0.101649732279060277715688770491228, 0.0915494682950492105281719397396142, 0.079920275333601701493392609529783, 0.0672509070508399303049409400473161, 0.053697017607756251228889163320458, 0.0389152304692994771150896322858629, 0.023036084038982232591084580367969, 0.00825771143316839575769392243921158};	//Weights for 37th order Gauss-Kronrod integration
	long double werr[] = {0.125556893905474335304296132860078, -0.12456288127724671156324996283372, 0.121626303523948383246099758091310, -0.116780483036597982467269153619148, 0.110022604977644072635907398742250, -0.101517694444005644033375685318571, 0.0915494682950492105281719397396142, -0.080158053209744524841259920013576, 0.0672509070508399303049409400473161, -0.053242308387562179731365554873538, 0.0389152304692994771150896322858629, -0.0241392523475295946035313811170481, 0.00825771143316839575769392243921158};	//Error weights for 37th order Gauss-Kronrod integration
#elif ORDER == 64
	long double Disp[] = {0.07296724759579058908806031209955, 0.14556185416089509093703098233869, 0.21738009387172883298179561608565, 0.28802131680240109660079251606460, 0.35712525365992107730319197431219, 0.42434212020743878357366888854379, 0.48929590889566864140105140228151, 0.55161883588721980705901879672431, 0.61099712378976603905186076209981, 0.66713880419741231930596666999034, 0.71972345257202475786195418640521, 0.76843996347567790861587785130623, 0.81305258084753191324907332122919, 0.85336336458331728364725063858757, 0.88912831533118433426270707847375, 0.92009933415040082879018713371497, 0.94614721677851262706535437885119, 0.96722683856630629431662221490770, 0.98318486356168595383392464989066, 0.99375217062038950026024203593794, 0.99896193068731718686198704308270};	//Displacement from center for 64th order Gauss-Kronrod integration
	long double w[] = {0.07302748796276908297314068625699, 0.0728456528305084410294911786777899, 0.072275482222034062651328264004603, 0.0712933463637845561021040045941832, 0.069929765008398753379866909680647, 0.0682207062610252150704081432085748, 0.066149577815951110013778554529288, 0.0636956152491007998422517557993921, 0.060898680204661962686034547272808, 0.0578104574976095223026959977828257, 0.054418675178383649262446811973774, 0.0506971977965175119748827957014245, 0.046697324731514497924831858406713, 0.0424969328811184855040644730480614, 0.038083153453465002583875378860838, 0.0334025463208076220711022803409528, 0.028518426570204953082884284481435, 0.0235741990830290305646428964274167, 0.018560055408876216262191994606715, 0.0133046426070883174480910406380580, 0.0078183373021241792478434900552220, 0.00279548123241156950861299678078312};	//Weights for 64th order Gauss-Kronrod integration
	long double werr[] = {-0.073053645686921344218844461426381, 0.0728456528305084410294911786777899, -0.072248921767935996412498902549150, 0.0712933463637845561021040045941832, -0.069957629782674401342266514186936, 0.0682207062610252150704081432085748, -0.066119360817386351767274019967487, 0.0636956152491007998422517557993921, -0.060932735849066571509332629852926, 0.0578104574976095223026959977828257, -0.054378623988764728401027766096332, 0.0506971977965175119748827957014245, -0.0467470987245193636284578827072191, 0.0424969328811184855040644730480614, -0.0380169601749142994331762744393456, 0.0334025463208076220711022803409528, -0.0286159988566522552007515419910130, 0.0235741990830290305646428964274167, -0.0183937343619762775377586736926149, 0.0133046426070883174480910406380580, -0.0081988909556501540763811268032490, 0.00279548123241156950861299678078312};	//Error weights for 64th order Gauss-Kronrod integration*/
#elif ORDER == 97
	long double Disp[] = {0.04830766568773831623481257044050, 0.09650269687689436580083125301636, 0.14447196158279649348518637359881, 0.19210360898314249727164159225259, 0.23928736225213707454460320916550, 0.28591245858945975941660710119035, 0.33186860228212764977991680573019, 0.37704942115412110544533548554981, 0.42135127613063534536411943617243, 0.46466930848199221775617820037971, 0.50689990893222939002374747437782, 0.54794631419915247868093950160974, 0.58771575724076232904074547640183, 0.62611293770182399782023837975795, 0.66304426693021520097511516866324, 0.69842655779521049288477014244748, 0.73218211874028968038742666509127, 0.76422825199780370415066012687437, 0.79448379596794240696309729897043, 0.82288295013605132164826884947213, 0.84936761373256997013369300496774, 0.87386976894531060612966180261363, 0.89632115576605212396530724371921, 0.91667726665136432427534565885792, 0.93490607593773968917091913483541, 0.95095468484866118538988275061533, 0.96476225558750643077381192811827, 0.97631028361466380719766964319312, 0.98561151154526833540017504463090, 0.99262803526297191268579115643847, 0.99726386184948156354498112866504, 0.99954590212436447863561028016112};	//Displacement from center for 97th order Gauss-Kronrod integration
	long double w[] = {0.0483263839865677583754454340005196, 0.04827019307577738559871207883299, 0.0481009691854577469278465438391581, 0.047818908736988472212263584657302, 0.0474260618738823823628799498539221, 0.046922968281703611103480713352515, 0.0463087567380257132403812984724432, 0.045585826564547070280575461963265, 0.0447586387497669372951991920753785, 0.043827544030139749046816152673798, 0.0427911155964467469336549254437386, 0.041654019985643051398296413297779, 0.0404234923703730966723492694215763, 0.039099420133306611207482127044236, 0.0376791306456133985148959737488490, 0.036169769475642299860958391303290, 0.0345821227447330341307263834168846, 0.032915077643903600263296476785556, 0.0311633255619737371711558486849664, 0.029336956689620661368615614585584, 0.0274520984222104037831477067959546, 0.025505695480894652814528899899308, 0.0234866596721633245920879128647720, 0.021408913184821915955777518020231, 0.0192987714303268112944037397635239, 0.017149805209784253256085826220233, 0.0149361036060860273850967513325094, 0.012676054806654402859368883399502, 0.0104239873988068188280342507620158, 0.0081725040385316684143438051192845, 0.00584173707916669330394797663999954, 0.0034268187757723709355745755785249, 0.00122336081795147180029303715064886};	//Weights for 97th order Gauss-Kronrod integration
	long double werr[] = {0.0483263839865677583754454340005196, -0.04826989543895041496805275123058, 0.0481009691854577469278465438391581, -0.047819811342286387206818417546829, 0.0474260618738823823628799498539221, -0.046921430799100954535699524315602, 0.0463087567380257132403812984724432, -0.045588052131216814432293115148372, 0.0447586387497669372951991920753785, -0.043824548974264062095955310078004, 0.0427911155964467469336549254437386, -0.041657904241303703823902661306570, 0.0404234923703730966723492694215763, -0.039094475653763695264258791784071, 0.0376791306456133985148959737488490, -0.036176024633206206364440965175198, 0.0345821227447330341307263834168846, -0.032907145132458246574353586921383, 0.0311633255619737371711558486849664, -0.029347136788914885776668022714587, 0.0274520984222104037831477067959546, -0.025492363781481523381634344790214, 0.0234866596721633245920879128647720, -0.0214269848374047647011011285858944, 0.0192987714303268112944037397635239, -0.0171240577032371798466019060321402, 0.0149361036060860273850967513325094, -0.0127160105026076565963837063897218, 0.0104239873988068188280342507620158, -0.0081018906923740021908267570871021, 0.00584173707916669330394797663999954, -0.0035917912336977256648324881603283, 0.00122336081795147180029303715064886};	//Error weights for 97th order Gauss-Kronrod integration
#endif
	long double Range[] = {-Boundary[7], -Boundary[6], -Boundary[5], -Boundary[4], -Boundary[3], -Boundary[2], -Boundary[1], -Boundary[0], 0, Boundary[0], Boundary[1], Boundary[2], Boundary[3], Boundary[4], Boundary[5], Boundary[6], Boundary[7]};
	long double Stops[36] = {0, 1, 3, 6, 9, 12, 15, 18, 21, 24, 34, 44, 54, 104, 204, 304, 404, 504, 552.25};	//Default subinterval
	long double a, b;			//Sub-interval limits of integration
	long double Max = 552.25;		//Upper limit of integration
	long double x1, x2;			//Abscissa
	pair<long double, long double> zero;	//Estimated pole of spectral function (zero of 1/f)
	int i, j;				//Counting varibles

	if(Q(P, Parameters[0][0], Parameters[0][1], Parameters[0][2])==0)
		return(pair<long double, long double>(0,0));

	Characterize(P, zero);
	for(i = 0; i < 17; i++)
		Stops[i+19] = pow(zero.first+zero.second*Range[i],2);	//Extra subintervals around the bound state

	mergeSort(Stops, 0, 35);

	i = 0;
	while(Stops[i] <= 0)	//skip all negative subintervals
		i++;

	a = 0;
	do
	{
		b = Stops[i];
		i++;

		if(b > Max)
			b = Max;

#if ORDER == 16
		for(j = 0; j < 5; j++) //Integrate the sub-interval
#elif ORDER == 37
		for(j = 0; j < 12; j++)
#elif ORDER == 64
		for(j = 0; j < 21; j++)
#elif ORDER == 97
		for(j = 0; j < 32; j++)
#endif
		{
			x1 = (b+a-Disp[j]*(b-a))/2.;
			x2 = (b+a+Disp[j]*(b-a))/2.;

			holder = SpatialGeneralKernel(x1, P, z)*Spectral(x1, P);
			Intergral[erri][i-1] += w[j+1]*wint*holder*(b-a)/2.;
			Error[erri][i-1] += werr[j+1]*werri*holder*(b-a)/2.;
			holder = SpatialGeneralKernel(x2, P, z)*Spectral(x2, P);
			Intergral[erri][i-1] += w[j+1]*wint*holder*(b-a)/2.;
			Error[erri][i-1] += werr[j+1]*werri*holder*(b-a)/2.;
		}
		holder = SpatialGeneralKernel(a/2.+b/2., P, z)*Spectral(a/2.+b/2., P);
		Intergral[erri][i-1] += w[0]*wint*holder*(b-a)/2.;
		Error[erri][i-1] += werr[0]*werri*holder*(b-a)/2.;
		a = b;
	}while(a < Max);

	return;
}

pair<long double, long double> Spectral_Inter::Spatial_P0Int(long double z, long double P0)
{
#if ORDER == 16
	long double Disp[] = {0.27963041316178319341346652274898, 0.53846931010568309103631442070021, 0.75416672657084922044081716694612, 0.90617984593866399279762687829939, 0.98408536009484246449617293463614};	//Displacement from center for 16th order Gauss-Kronrod integration from Mathematica
	long double w[] = {0.28298741785749121320425560137111, 0.272849801912558922340993264484456, 0.24104033922864758669994261122326, 0.186800796556492657467800026878486, 0.115233316622473394024626845880574, 0.0425820367510818328645094508476701};	//Weight of the function at Disp
	long double werr[] = {0.272849801912558922340993264484456, -0.28590147103139767568463328751778, 0.272849801912558922340993264484456, -0.237588331270718881341348903612376, 0.186800796556492657467800026878486, -0.121693568433715693489637194839344, 0.0425820367510818328645094508476701};	//Weight of the error estimate function at Disp
#elif ORDER == 37
	long double Disp[] = {0.12523340851146891547244136946385, 0.24850574832046927626779096036272, 0.36783149899818019375269153664372, 0.48133945047815709293594361501883, 0.58731795428661744729670241894053, 0.68405989547005589394492910034115, 0.76990267419430468703689383321282, 0.84355812416115324479214188505984, 0.90411725637047485667846586611910, 0.95053779594312129654906019513162, 0.98156063424671925069054909014928, 0.99693392252959542691235023725839};	//Displacement from center for 37th order Gauss-Kronrod integration
	long double w[] = {0.125556893905474335304296132860078, 0.12458416453615607343731247320923, 0.121626303523948383246099758091310, 0.11671205350175682629358074530573, 0.110022604977644072635907398742250, 0.101649732279060277715688770491228, 0.0915494682950492105281719397396142, 0.079920275333601701493392609529783, 0.0672509070508399303049409400473161, 0.053697017607756251228889163320458, 0.0389152304692994771150896322858629, 0.023036084038982232591084580367969, 0.00825771143316839575769392243921158};	//Weights for 37th order Gauss-Kronrod integration
	long double werr[] = {0.125556893905474335304296132860078, -0.12456288127724671156324996283372, 0.121626303523948383246099758091310, -0.116780483036597982467269153619148, 0.110022604977644072635907398742250, -0.101517694444005644033375685318571, 0.0915494682950492105281719397396142, -0.080158053209744524841259920013576, 0.0672509070508399303049409400473161, -0.053242308387562179731365554873538, 0.0389152304692994771150896322858629, -0.0241392523475295946035313811170481, 0.00825771143316839575769392243921158};	//Error weights for 37th order Gauss-Kronrod integration
#elif ORDER == 64
	long double Disp[] = {0.07296724759579058908806031209955, 0.14556185416089509093703098233869, 0.21738009387172883298179561608565, 0.28802131680240109660079251606460, 0.35712525365992107730319197431219, 0.42434212020743878357366888854379, 0.48929590889566864140105140228151, 0.55161883588721980705901879672431, 0.61099712378976603905186076209981, 0.66713880419741231930596666999034, 0.71972345257202475786195418640521, 0.76843996347567790861587785130623, 0.81305258084753191324907332122919, 0.85336336458331728364725063858757, 0.88912831533118433426270707847375, 0.92009933415040082879018713371497, 0.94614721677851262706535437885119, 0.96722683856630629431662221490770, 0.98318486356168595383392464989066, 0.99375217062038950026024203593794, 0.99896193068731718686198704308270};	//Displacement from center for 64th order Gauss-Kronrod integration
	long double w[] = {0.07302748796276908297314068625699, 0.0728456528305084410294911786777899, 0.072275482222034062651328264004603, 0.0712933463637845561021040045941832, 0.069929765008398753379866909680647, 0.0682207062610252150704081432085748, 0.066149577815951110013778554529288, 0.0636956152491007998422517557993921, 0.060898680204661962686034547272808, 0.0578104574976095223026959977828257, 0.054418675178383649262446811973774, 0.0506971977965175119748827957014245, 0.046697324731514497924831858406713, 0.0424969328811184855040644730480614, 0.038083153453465002583875378860838, 0.0334025463208076220711022803409528, 0.028518426570204953082884284481435, 0.0235741990830290305646428964274167, 0.018560055408876216262191994606715, 0.0133046426070883174480910406380580, 0.0078183373021241792478434900552220, 0.00279548123241156950861299678078312};	//Weights for 64th order Gauss-Kronrod integration
	long double werr[] = {-0.073053645686921344218844461426381, 0.0728456528305084410294911786777899, -0.072248921767935996412498902549150, 0.0712933463637845561021040045941832, -0.069957629782674401342266514186936, 0.0682207062610252150704081432085748, -0.066119360817386351767274019967487, 0.0636956152491007998422517557993921, -0.060932735849066571509332629852926, 0.0578104574976095223026959977828257, -0.054378623988764728401027766096332, 0.0506971977965175119748827957014245, -0.0467470987245193636284578827072191, 0.0424969328811184855040644730480614, -0.0380169601749142994331762744393456, 0.0334025463208076220711022803409528, -0.0286159988566522552007515419910130, 0.0235741990830290305646428964274167, -0.0183937343619762775377586736926149, 0.0133046426070883174480910406380580, -0.0081988909556501540763811268032490, 0.00279548123241156950861299678078312};	//Error weights for 64th order Gauss-Kronrod integration*/
#elif ORDER == 97
	long double Disp[] = {0.04830766568773831623481257044050, 0.09650269687689436580083125301636, 0.14447196158279649348518637359881, 0.19210360898314249727164159225259, 0.23928736225213707454460320916550, 0.28591245858945975941660710119035, 0.33186860228212764977991680573019, 0.37704942115412110544533548554981, 0.42135127613063534536411943617243, 0.46466930848199221775617820037971, 0.50689990893222939002374747437782, 0.54794631419915247868093950160974, 0.58771575724076232904074547640183, 0.62611293770182399782023837975795, 0.66304426693021520097511516866324, 0.69842655779521049288477014244748, 0.73218211874028968038742666509127, 0.76422825199780370415066012687437, 0.79448379596794240696309729897043, 0.82288295013605132164826884947213, 0.84936761373256997013369300496774, 0.87386976894531060612966180261363, 0.89632115576605212396530724371921, 0.91667726665136432427534565885792, 0.93490607593773968917091913483541, 0.95095468484866118538988275061533, 0.96476225558750643077381192811827, 0.97631028361466380719766964319312, 0.98561151154526833540017504463090, 0.99262803526297191268579115643847, 0.99726386184948156354498112866504, 0.99954590212436447863561028016112};	//Displacement from center for 97th order Gauss-Kronrod integration
	long double w[] = {0.0483263839865677583754454340005196, 0.04827019307577738559871207883299, 0.0481009691854577469278465438391581, 0.047818908736988472212263584657302, 0.0474260618738823823628799498539221, 0.046922968281703611103480713352515, 0.0463087567380257132403812984724432, 0.045585826564547070280575461963265, 0.0447586387497669372951991920753785, 0.043827544030139749046816152673798, 0.0427911155964467469336549254437386, 0.041654019985643051398296413297779, 0.0404234923703730966723492694215763, 0.039099420133306611207482127044236, 0.0376791306456133985148959737488490, 0.036169769475642299860958391303290, 0.0345821227447330341307263834168846, 0.032915077643903600263296476785556, 0.0311633255619737371711558486849664, 0.029336956689620661368615614585584, 0.0274520984222104037831477067959546, 0.025505695480894652814528899899308, 0.0234866596721633245920879128647720, 0.021408913184821915955777518020231, 0.0192987714303268112944037397635239, 0.017149805209784253256085826220233, 0.0149361036060860273850967513325094, 0.012676054806654402859368883399502, 0.0104239873988068188280342507620158, 0.0081725040385316684143438051192845, 0.00584173707916669330394797663999954, 0.0034268187757723709355745755785249, 0.00122336081795147180029303715064886};	//Weights for 97th order Gauss-Kronrod integration
	long double werr[] = {0.0483263839865677583754454340005196, -0.04826989543895041496805275123058, 0.0481009691854577469278465438391581, -0.047819811342286387206818417546829, 0.0474260618738823823628799498539221, -0.046921430799100954535699524315602, 0.0463087567380257132403812984724432, -0.045588052131216814432293115148372, 0.0447586387497669372951991920753785, -0.043824548974264062095955310078004, 0.0427911155964467469336549254437386, -0.041657904241303703823902661306570, 0.0404234923703730966723492694215763, -0.039094475653763695264258791784071, 0.0376791306456133985148959737488490, -0.036176024633206206364440965175198, 0.0345821227447330341307263834168846, -0.032907145132458246574353586921383, 0.0311633255619737371711558486849664, -0.029347136788914885776668022714587, 0.0274520984222104037831477067959546, -0.025492363781481523381634344790214, 0.0234866596721633245920879128647720, -0.0214269848374047647011011285858944, 0.0192987714303268112944037397635239, -0.0171240577032371798466019060321402, 0.0149361036060860273850967513325094, -0.0127160105026076565963837063897218, 0.0104239873988068188280342507620158, -0.0081018906923740021908267570871021, 0.00584173707916669330394797663999954, -0.0035917912336977256648324881603283, 0.00122336081795147180029303715064886};	//Error weights for 97th order Gauss-Kronrod integration
#endif
	long double Range[] = {-Boundary[7], -Boundary[6], -Boundary[5], -Boundary[4], -Boundary[3], -Boundary[2], -Boundary[1], -Boundary[0], 0, Boundary[0], Boundary[1], Boundary[2], Boundary[3], Boundary[4], Boundary[5], Boundary[6], Boundary[7]};
	long double Stops[34] = {3, 6, 9, 12, 15, 18, 21, 24, 34, 44, 54, 104, 204, 304, 404, 504, 552.25};	//Default subintervals
	long double x1, x2;				//Abscissa
	long double a, b;				//Sub-interval limits of integration
	long double Max = 552.25;			//Upper limit of integration
	long double F;					//Sum of ordinates*weights
	long double Ferr;				//Sum of ordinates*err weights
	pair<long double, long double> Answer(0,0);	//Results to be returned
	pair<long double, long double> zero;		//Estimated pole of spectral function (zero of 1/f)
	long double holder;
	int i, j;					//Counting varibles

	if(Q(P0, Parameters[0][0], Parameters[0][1], Parameters[0][2])==0)
		return(pair<long double, long double>(0,0));

	Characterize(P0, zero);
	for(i = 0; i < 17; i++)
		Stops[i+17] = pow(zero.first+zero.second*Range[i],2);	//Extra subintervals around the bound state

	mergeSort(Stops, 0, 33);

	i = 0;
	while(Stops[i] < 0)	//Discard negative subintervals
		i++;

	a = 0;
	do
	{
		b = Stops[i];
		i++;

		if(b > Max)
			b = Max;

		F = 0;
		Ferr = 0;

#if ORDER == 16
		for(j = 0; j < 5; j++) //Integrate the sub-interval
#elif ORDER == 37
		for(j = 0; j < 12; j++)
#elif ORDER == 64
		for(j = 0; j < 21; j++)
#elif ORDER == 97
		for(j = 0; j < 32; j++)
#endif
		{
			x1 = (b+a-Disp[j]*(b-a))/2.;
			x2 = (b+a+Disp[j]*(b-a))/2.;

			holder = SpatialCutoffKernel(x1, P0, z)*Spectral(x1, P0);
			F += w[j+1]*holder;
			Ferr += werr[j+1]*holder;
			holder = SpatialCutoffKernel(x2, P0, z)*Spectral(x2, P0);
			F += w[j+1]*holder;
			Ferr += werr[j+1]*holder;
		}
		holder = SpatialCutoffKernel(a/2.+b/2., P0, z)*Spectral(a/2.+b/2., P0);
		F += w[0]*holder;
		Ferr += werr[0]*holder;
		Answer.first += F*(b-a)/2.;
		Answer.second += abs(Ferr*(b-a)/2.);
		a = b;
	}while(a < Max);

	return(Answer);
}

pair<long double, long double> Spectral_Inter::Spatial_Lorentz(long double z)
{
#if ORDER == 16
	long double Disp[] = {0.27963041316178319341346652274898, 0.53846931010568309103631442070021, 0.75416672657084922044081716694612, 0.90617984593866399279762687829939, 0.98408536009484246449617293463614};	//Displacement from center for 16th order Gauss-Kronrod integration from Mathematica
	long double w[] = {0.28298741785749121320425560137111, 0.272849801912558922340993264484456, 0.24104033922864758669994261122326, 0.186800796556492657467800026878486, 0.115233316622473394024626845880574, 0.0425820367510818328645094508476701};	//Weight of the function at Disp
	long double werr[] = {0.272849801912558922340993264484456, -0.28590147103139767568463328751778, 0.272849801912558922340993264484456, -0.237588331270718881341348903612376, 0.186800796556492657467800026878486, -0.121693568433715693489637194839344, 0.0425820367510818328645094508476701};	//Weight of the error estimate function at Disp
#elif ORDER == 37
	long double Disp[] = {0.12523340851146891547244136946385, 0.24850574832046927626779096036272, 0.36783149899818019375269153664372, 0.48133945047815709293594361501883, 0.58731795428661744729670241894053, 0.68405989547005589394492910034115, 0.76990267419430468703689383321282, 0.84355812416115324479214188505984, 0.90411725637047485667846586611910, 0.95053779594312129654906019513162, 0.98156063424671925069054909014928, 0.99693392252959542691235023725839};	//Displacement from center for 37th order Gauss-Kronrod integration
	long double w[] = {0.125556893905474335304296132860078, 0.12458416453615607343731247320923, 0.121626303523948383246099758091310, 0.11671205350175682629358074530573, 0.110022604977644072635907398742250, 0.101649732279060277715688770491228, 0.0915494682950492105281719397396142, 0.079920275333601701493392609529783, 0.0672509070508399303049409400473161, 0.053697017607756251228889163320458, 0.0389152304692994771150896322858629, 0.023036084038982232591084580367969, 0.00825771143316839575769392243921158};	//Weights for 37th order Gauss-Kronrod integration
	long double werr[] = {0.125556893905474335304296132860078, -0.12456288127724671156324996283372, 0.121626303523948383246099758091310, -0.116780483036597982467269153619148, 0.110022604977644072635907398742250, -0.101517694444005644033375685318571, 0.0915494682950492105281719397396142, -0.080158053209744524841259920013576, 0.0672509070508399303049409400473161, -0.053242308387562179731365554873538, 0.0389152304692994771150896322858629, -0.0241392523475295946035313811170481, 0.00825771143316839575769392243921158};	//Error weights for 37th order Gauss-Kronrod integration
#elif ORDER == 64
	long double Disp[] = {0.07296724759579058908806031209955, 0.14556185416089509093703098233869, 0.21738009387172883298179561608565, 0.28802131680240109660079251606460, 0.35712525365992107730319197431219, 0.42434212020743878357366888854379, 0.48929590889566864140105140228151, 0.55161883588721980705901879672431, 0.61099712378976603905186076209981, 0.66713880419741231930596666999034, 0.71972345257202475786195418640521, 0.76843996347567790861587785130623, 0.81305258084753191324907332122919, 0.85336336458331728364725063858757, 0.88912831533118433426270707847375, 0.92009933415040082879018713371497, 0.94614721677851262706535437885119, 0.96722683856630629431662221490770, 0.98318486356168595383392464989066, 0.99375217062038950026024203593794, 0.99896193068731718686198704308270};	//Displacement from center for 64th order Gauss-Kronrod integration
	long double w[] = {0.07302748796276908297314068625699, 0.0728456528305084410294911786777899, 0.072275482222034062651328264004603, 0.0712933463637845561021040045941832, 0.069929765008398753379866909680647, 0.0682207062610252150704081432085748, 0.066149577815951110013778554529288, 0.0636956152491007998422517557993921, 0.060898680204661962686034547272808, 0.0578104574976095223026959977828257, 0.054418675178383649262446811973774, 0.0506971977965175119748827957014245, 0.046697324731514497924831858406713, 0.0424969328811184855040644730480614, 0.038083153453465002583875378860838, 0.0334025463208076220711022803409528, 0.028518426570204953082884284481435, 0.0235741990830290305646428964274167, 0.018560055408876216262191994606715, 0.0133046426070883174480910406380580, 0.0078183373021241792478434900552220, 0.00279548123241156950861299678078312};	//Weights for 64th order Gauss-Kronrod integration
	long double werr[] = {-0.073053645686921344218844461426381, 0.0728456528305084410294911786777899, -0.072248921767935996412498902549150, 0.0712933463637845561021040045941832, -0.069957629782674401342266514186936, 0.0682207062610252150704081432085748, -0.066119360817386351767274019967487, 0.0636956152491007998422517557993921, -0.060932735849066571509332629852926, 0.0578104574976095223026959977828257, -0.054378623988764728401027766096332, 0.0506971977965175119748827957014245, -0.0467470987245193636284578827072191, 0.0424969328811184855040644730480614, -0.0380169601749142994331762744393456, 0.0334025463208076220711022803409528, -0.0286159988566522552007515419910130, 0.0235741990830290305646428964274167, -0.0183937343619762775377586736926149, 0.0133046426070883174480910406380580, -0.0081988909556501540763811268032490, 0.00279548123241156950861299678078312};	//Error weights for 64th order Gauss-Kronrod integration*/
#elif ORDER == 97
	long double Disp[] = {0.04830766568773831623481257044050, 0.09650269687689436580083125301636, 0.14447196158279649348518637359881, 0.19210360898314249727164159225259, 0.23928736225213707454460320916550, 0.28591245858945975941660710119035, 0.33186860228212764977991680573019, 0.37704942115412110544533548554981, 0.42135127613063534536411943617243, 0.46466930848199221775617820037971, 0.50689990893222939002374747437782, 0.54794631419915247868093950160974, 0.58771575724076232904074547640183, 0.62611293770182399782023837975795, 0.66304426693021520097511516866324, 0.69842655779521049288477014244748, 0.73218211874028968038742666509127, 0.76422825199780370415066012687437, 0.79448379596794240696309729897043, 0.82288295013605132164826884947213, 0.84936761373256997013369300496774, 0.87386976894531060612966180261363, 0.89632115576605212396530724371921, 0.91667726665136432427534565885792, 0.93490607593773968917091913483541, 0.95095468484866118538988275061533, 0.96476225558750643077381192811827, 0.97631028361466380719766964319312, 0.98561151154526833540017504463090, 0.99262803526297191268579115643847, 0.99726386184948156354498112866504, 0.99954590212436447863561028016112};	//Displacement from center for 97th order Gauss-Kronrod integration
	long double w[] = {0.0483263839865677583754454340005196, 0.04827019307577738559871207883299, 0.0481009691854577469278465438391581, 0.047818908736988472212263584657302, 0.0474260618738823823628799498539221, 0.046922968281703611103480713352515, 0.0463087567380257132403812984724432, 0.045585826564547070280575461963265, 0.0447586387497669372951991920753785, 0.043827544030139749046816152673798, 0.0427911155964467469336549254437386, 0.041654019985643051398296413297779, 0.0404234923703730966723492694215763, 0.039099420133306611207482127044236, 0.0376791306456133985148959737488490, 0.036169769475642299860958391303290, 0.0345821227447330341307263834168846, 0.032915077643903600263296476785556, 0.0311633255619737371711558486849664, 0.029336956689620661368615614585584, 0.0274520984222104037831477067959546, 0.025505695480894652814528899899308, 0.0234866596721633245920879128647720, 0.021408913184821915955777518020231, 0.0192987714303268112944037397635239, 0.017149805209784253256085826220233, 0.0149361036060860273850967513325094, 0.012676054806654402859368883399502, 0.0104239873988068188280342507620158, 0.0081725040385316684143438051192845, 0.00584173707916669330394797663999954, 0.0034268187757723709355745755785249, 0.00122336081795147180029303715064886};	//Weights for 97th order Gauss-Kronrod integration
	long double werr[] = {0.0483263839865677583754454340005196, -0.04826989543895041496805275123058, 0.0481009691854577469278465438391581, -0.047819811342286387206818417546829, 0.0474260618738823823628799498539221, -0.046921430799100954535699524315602, 0.0463087567380257132403812984724432, -0.045588052131216814432293115148372, 0.0447586387497669372951991920753785, -0.043824548974264062095955310078004, 0.0427911155964467469336549254437386, -0.041657904241303703823902661306570, 0.0404234923703730966723492694215763, -0.039094475653763695264258791784071, 0.0376791306456133985148959737488490, -0.036176024633206206364440965175198, 0.0345821227447330341307263834168846, -0.032907145132458246574353586921383, 0.0311633255619737371711558486849664, -0.029347136788914885776668022714587, 0.0274520984222104037831477067959546, -0.025492363781481523381634344790214, 0.0234866596721633245920879128647720, -0.0214269848374047647011011285858944, 0.0192987714303268112944037397635239, -0.0171240577032371798466019060321402, 0.0149361036060860273850967513325094, -0.0127160105026076565963837063897218, 0.0104239873988068188280342507620158, -0.0081018906923740021908267570871021, 0.00584173707916669330394797663999954, -0.0035917912336977256648324881603283, 0.00122336081795147180029303715064886};	//Error weights for 97th order Gauss-Kronrod integration
#endif
	long double Range[] = {-Boundary[7], -Boundary[6], -Boundary[5], -Boundary[4], -Boundary[3], -Boundary[2], -Boundary[1], -Boundary[0], 0, Boundary[0], Boundary[1], Boundary[2], Boundary[3], Boundary[4], Boundary[5], Boundary[6], Boundary[7]};
	long double Stops[34] = {3, 6, 9, 12, 15, 18, 21, 24, 34, 44, 54, 104, 204, 304, 404, 504, 552.25};	//Default subintervals
	long double x1, x2;				//Abscissa
	long double a, b;				//Sub-interval limits of integration
	long double Max = 552.25;			//Upper limit of integration
	long double F;					//Sum of ordinates*weights
	long double Ferr;				//Sum of ordinates*err weights
	pair<long double, long double> Answer(0,0);	//Results to be returned
	pair<long double, long double> zero;		//Estimated pole of spectral function (zero of 1/f)
	long double holder;
	int i, j;					//Counting varibles

	if(Parameters[0][0]==0)
		return(pair<long double, long double>(0,0));

	Characterize(0, zero);
	for(i = 0; i < 17; i++)
		Stops[i+17] = pow(zero.first+zero.second*Range[i],2);	//Extra subintervals around the bound state

	mergeSort(Stops, 0, 33);

	i = 0;
	while(Stops[i] < 0)	//Discard negative subintervals
		i++;

	a = b = 0;
	do
	{
		b = Stops[i];
		i++;

		if(b > Max)
			b = Max;

		F = 0;
		Ferr = 0;

#if ORDER == 16
		for(j = 0; j < 5; j++) //Integrate the sub-interval
#elif ORDER == 37
		for(j = 0; j < 12; j++)
#elif ORDER == 64
		for(j = 0; j < 21; j++)
#elif ORDER == 97
		for(j = 0; j < 32; j++)
#endif
		{
			x1 = (b+a-Disp[j]*(b-a))/2.;
			x2 = (b+a+Disp[j]*(b-a))/2.;

			holder = SpatialLorentzKernel(x1, z)*Spectral(x1, 0);
			F += w[j+1]*holder;
			Ferr += werr[j+1]*holder;
			holder = SpatialLorentzKernel(x2, z)*Spectral(x2, 0);
			F += w[j+1]*holder;
			Ferr += werr[j+1]*holder;
		}
		holder = SpatialLorentzKernel(a/2.+b/2., z)*Spectral(a/2.+b/2., 0);
		F += w[0]*holder;
		Ferr += werr[0]*holder;
		Answer.first += F*(b-a)/2.;
		Answer.second += abs(Ferr*(b-a)/2.);
		a = b;
	}while(a < Max);

	return(Answer);
}

pair<long double, long double> Spectral_Inter::Euclidean(long double tau, long double P)
{
	return(Euclidean(tau, P, Temp));	//Why have the same code twice if the T is only thing different
}

pair<long double, long double> Spectral_Inter::Euclidean(long double tau, long double P, long double T)
{
#if ORDER == 16
	long double Disp[] = {0.27963041316178319341346652274898, 0.53846931010568309103631442070021, 0.75416672657084922044081716694612, 0.90617984593866399279762687829939, 0.98408536009484246449617293463614};	//Displacement from center for 16th order Gauss-Kronrod integration from Mathematica
	long double w[] = {0.28298741785749121320425560137111, 0.272849801912558922340993264484456, 0.24104033922864758669994261122326, 0.186800796556492657467800026878486, 0.115233316622473394024626845880574, 0.0425820367510818328645094508476701};	//Weight of the function at Disp
	long double werr[] = {0.272849801912558922340993264484456, -0.28590147103139767568463328751778, 0.272849801912558922340993264484456, -0.237588331270718881341348903612376, 0.186800796556492657467800026878486, -0.121693568433715693489637194839344, 0.0425820367510818328645094508476701};	//Weight of the error estimate function at Disp
#elif ORDER == 37
	long double Disp[] = {0.12523340851146891547244136946385, 0.24850574832046927626779096036272, 0.36783149899818019375269153664372, 0.48133945047815709293594361501883, 0.58731795428661744729670241894053, 0.68405989547005589394492910034115, 0.76990267419430468703689383321282, 0.84355812416115324479214188505984, 0.90411725637047485667846586611910, 0.95053779594312129654906019513162, 0.98156063424671925069054909014928, 0.99693392252959542691235023725839};	//Displacement from center for 37th order Gauss-Kronrod integration
	long double w[] = {0.125556893905474335304296132860078, 0.12458416453615607343731247320923, 0.121626303523948383246099758091310, 0.11671205350175682629358074530573, 0.110022604977644072635907398742250, 0.101649732279060277715688770491228, 0.0915494682950492105281719397396142, 0.079920275333601701493392609529783, 0.0672509070508399303049409400473161, 0.053697017607756251228889163320458, 0.0389152304692994771150896322858629, 0.023036084038982232591084580367969, 0.00825771143316839575769392243921158};	//Weights for 37th order Gauss-Kronrod integration
	long double werr[] = {0.125556893905474335304296132860078, -0.12456288127724671156324996283372, 0.121626303523948383246099758091310, -0.116780483036597982467269153619148, 0.110022604977644072635907398742250, -0.101517694444005644033375685318571, 0.0915494682950492105281719397396142, -0.080158053209744524841259920013576, 0.0672509070508399303049409400473161, -0.053242308387562179731365554873538, 0.0389152304692994771150896322858629, -0.0241392523475295946035313811170481, 0.00825771143316839575769392243921158};	//Error weights for 37th order Gauss-Kronrod integration
#elif ORDER == 64
	long double Disp[] = {0.07296724759579058908806031209955, 0.14556185416089509093703098233869, 0.21738009387172883298179561608565, 0.28802131680240109660079251606460, 0.35712525365992107730319197431219, 0.42434212020743878357366888854379, 0.48929590889566864140105140228151, 0.55161883588721980705901879672431, 0.61099712378976603905186076209981, 0.66713880419741231930596666999034, 0.71972345257202475786195418640521, 0.76843996347567790861587785130623, 0.81305258084753191324907332122919, 0.85336336458331728364725063858757, 0.88912831533118433426270707847375, 0.92009933415040082879018713371497, 0.94614721677851262706535437885119, 0.96722683856630629431662221490770, 0.98318486356168595383392464989066, 0.99375217062038950026024203593794, 0.99896193068731718686198704308270};	//Displacement from center for 64th order Gauss-Kronrod integration
	long double w[] = {0.07302748796276908297314068625699, 0.0728456528305084410294911786777899, 0.072275482222034062651328264004603, 0.0712933463637845561021040045941832, 0.069929765008398753379866909680647, 0.0682207062610252150704081432085748, 0.066149577815951110013778554529288, 0.0636956152491007998422517557993921, 0.060898680204661962686034547272808, 0.0578104574976095223026959977828257, 0.054418675178383649262446811973774, 0.0506971977965175119748827957014245, 0.046697324731514497924831858406713, 0.0424969328811184855040644730480614, 0.038083153453465002583875378860838, 0.0334025463208076220711022803409528, 0.028518426570204953082884284481435, 0.0235741990830290305646428964274167, 0.018560055408876216262191994606715, 0.0133046426070883174480910406380580, 0.0078183373021241792478434900552220, 0.00279548123241156950861299678078312};	//Weights for 64th order Gauss-Kronrod integration
	long double werr[] = {-0.073053645686921344218844461426381, 0.0728456528305084410294911786777899, -0.072248921767935996412498902549150, 0.0712933463637845561021040045941832, -0.069957629782674401342266514186936, 0.0682207062610252150704081432085748, -0.066119360817386351767274019967487, 0.0636956152491007998422517557993921, -0.060932735849066571509332629852926, 0.0578104574976095223026959977828257, -0.054378623988764728401027766096332, 0.0506971977965175119748827957014245, -0.0467470987245193636284578827072191, 0.0424969328811184855040644730480614, -0.0380169601749142994331762744393456, 0.0334025463208076220711022803409528, -0.0286159988566522552007515419910130, 0.0235741990830290305646428964274167, -0.0183937343619762775377586736926149, 0.0133046426070883174480910406380580, -0.0081988909556501540763811268032490, 0.00279548123241156950861299678078312};	//Error weights for 64th order Gauss-Kronrod integration*/
#elif ORDER == 97
	long double Disp[] = {0.04830766568773831623481257044050, 0.09650269687689436580083125301636, 0.14447196158279649348518637359881, 0.19210360898314249727164159225259, 0.23928736225213707454460320916550, 0.28591245858945975941660710119035, 0.33186860228212764977991680573019, 0.37704942115412110544533548554981, 0.42135127613063534536411943617243, 0.46466930848199221775617820037971, 0.50689990893222939002374747437782, 0.54794631419915247868093950160974, 0.58771575724076232904074547640183, 0.62611293770182399782023837975795, 0.66304426693021520097511516866324, 0.69842655779521049288477014244748, 0.73218211874028968038742666509127, 0.76422825199780370415066012687437, 0.79448379596794240696309729897043, 0.82288295013605132164826884947213, 0.84936761373256997013369300496774, 0.87386976894531060612966180261363, 0.89632115576605212396530724371921, 0.91667726665136432427534565885792, 0.93490607593773968917091913483541, 0.95095468484866118538988275061533, 0.96476225558750643077381192811827, 0.97631028361466380719766964319312, 0.98561151154526833540017504463090, 0.99262803526297191268579115643847, 0.99726386184948156354498112866504, 0.99954590212436447863561028016112};	//Displacement from center for 97th order Gauss-Kronrod integration
	long double w[] = {0.0483263839865677583754454340005196, 0.04827019307577738559871207883299, 0.0481009691854577469278465438391581, 0.047818908736988472212263584657302, 0.0474260618738823823628799498539221, 0.046922968281703611103480713352515, 0.0463087567380257132403812984724432, 0.045585826564547070280575461963265, 0.0447586387497669372951991920753785, 0.043827544030139749046816152673798, 0.0427911155964467469336549254437386, 0.041654019985643051398296413297779, 0.0404234923703730966723492694215763, 0.039099420133306611207482127044236, 0.0376791306456133985148959737488490, 0.036169769475642299860958391303290, 0.0345821227447330341307263834168846, 0.032915077643903600263296476785556, 0.0311633255619737371711558486849664, 0.029336956689620661368615614585584, 0.0274520984222104037831477067959546, 0.025505695480894652814528899899308, 0.0234866596721633245920879128647720, 0.021408913184821915955777518020231, 0.0192987714303268112944037397635239, 0.017149805209784253256085826220233, 0.0149361036060860273850967513325094, 0.012676054806654402859368883399502, 0.0104239873988068188280342507620158, 0.0081725040385316684143438051192845, 0.00584173707916669330394797663999954, 0.0034268187757723709355745755785249, 0.00122336081795147180029303715064886};	//Weights for 97th order Gauss-Kronrod integration
	long double werr[] = {0.0483263839865677583754454340005196, -0.04826989543895041496805275123058, 0.0481009691854577469278465438391581, -0.047819811342286387206818417546829, 0.0474260618738823823628799498539221, -0.046921430799100954535699524315602, 0.0463087567380257132403812984724432, -0.045588052131216814432293115148372, 0.0447586387497669372951991920753785, -0.043824548974264062095955310078004, 0.0427911155964467469336549254437386, -0.041657904241303703823902661306570, 0.0404234923703730966723492694215763, -0.039094475653763695264258791784071, 0.0376791306456133985148959737488490, -0.036176024633206206364440965175198, 0.0345821227447330341307263834168846, -0.032907145132458246574353586921383, 0.0311633255619737371711558486849664, -0.029347136788914885776668022714587, 0.0274520984222104037831477067959546, -0.025492363781481523381634344790214, 0.0234866596721633245920879128647720, -0.0214269848374047647011011285858944, 0.0192987714303268112944037397635239, -0.0171240577032371798466019060321402, 0.0149361036060860273850967513325094, -0.0127160105026076565963837063897218, 0.0104239873988068188280342507620158, -0.0081018906923740021908267570871021, 0.00584173707916669330394797663999954, -0.0035917912336977256648324881603283, 0.00122336081795147180029303715064886};	//Error weights for 97th order Gauss-Kronrod integration
#endif
	long double Range[] = {-Boundary[7], -Boundary[6], -Boundary[5], -Boundary[4], -Boundary[3], -Boundary[2], -Boundary[1], -Boundary[0], 0, Boundary[0], Boundary[1], Boundary[2], Boundary[3], Boundary[4], Boundary[5], Boundary[6], Boundary[7]};
	long double Stops[60] = {3, 6, 18, 21, 24, 34, 44, 54, 104, 204, 304, 404, 504, 604, 704, 804, 904, 1004, 2004, 3004, 4004, 5004, 6004, 7004, 8004, 9004, 10004, 10004, 20004, 30004, 40004, 50004, 60004, 70004, 80004, 90004, 100004, 110004, 120004, 130004, 140004, 150004, 160000};	//Default stops
	long double a, b;				//Sub-interval limits of integration
	long double x1, x2;				//Abscissa
	long double Max = pow(400.,2);		//Upper limit of integration
	long double F;					//Sum of ordinates*weights
	long double Ferr;				//Sum of ordinates*err weights
	pair<long double, long double> Answer(0,0);	//Results to be returned
	long double holder;
	pair<long double, long double> zero;		//Estimated pole of spectral function (zero of 1/f)
	int i, j;					//Counting varibles

	if(Q(P, Parameters[0][0], Parameters[0][1], Parameters[0][2])==0)
		return(pair<long double, long double>(0,0));

	Characterize(P, zero);
	for(i = 0; i < 17; i++)
		Stops[i+43] = pow(zero.first+zero.second*Range[i],2);	//Extra stops around the bound state

	mergeSort(Stops, 0, 59);

	i = 0;
	while(Stops[i] < 0)	//Skip negative subintervals
		i++;

	tau /= T;

	a = b = 0;
	do
	{
		b = Stops[i];
		i++;

		if(b > Max)
			b = Max;

		F = 0;
		Ferr = 0;

#if ORDER == 16
		for(j = 0; j < 5; j++) //Integrate the sub-interval
#elif ORDER == 37
		for(j = 0; j < 12; j++)
#elif ORDER == 64
		for(j = 0; j < 21; j++)
#elif ORDER == 97
		for(j = 0; j < 32; j++)
#endif
		{
			x1 = (b+a-Disp[j]*(b-a))/2.;
			x2 = (b+a+Disp[j]*(b-a))/2.;

			holder = EuclideanKernel(x1, P, tau, T)*Spectral(x1, P);
			F += w[j+1]*holder;
			Ferr += werr[j+1]*holder;
			holder = EuclideanKernel(x2, P, tau, T)*Spectral(x2, P);
			F += w[j+1]*holder;
			Ferr += werr[j+1]*holder;
		}
		holder = EuclideanKernel(a/2.+b/2., P, tau, T)*Spectral(a/2.+b/2., P);
		F += w[0]*holder;
		Ferr += werr[0]*holder;

		Answer.first += F*(b-a)/2.;
		Answer.second += abs(Ferr*(b-a)/2.);
		a = b;
	}while(a < Max);

	return(Answer);
}

void Spectral_Inter::Characterize(long double P, pair<long double, long double>& zero)
{
	long double M_old = Q(P,Parameters[1][0],Parameters[1][1],Parameters[1][2]);	//Initial estimate from parameter inputs
	long double M_new;
	long double h = .00001;
	int i = 0;

	M_new = M_old - h*(1./Spectral(pow(M_old+h,2), P)-1./Spectral(pow(M_old,2), P))/(1./Spectral(pow(M_old-h,2), P)-2.*1./Spectral(pow(M_old,2), P)+1./Spectral(pow(M_old+h,2), P));	//Newton's method for finding extrema on 1/f

	while(abs(M_new/M_old-1.) > 1e-5 && i < 20)	//Take up to 20 interations
	{
		M_old = M_new;
		M_new = M_old - h*(1./Spectral(pow(M_old+h,2), P)-1./Spectral(pow(M_old,2), P))/(1./Spectral(pow(M_old-h,2), P)-2./Spectral(pow(M_old,2), P)+1./Spectral(pow(M_old+h,2), P));
		i++;
	}

	zero.first = M_new;
	zero.second = 2.*sqrt(-pow(h,2)*Spectral(pow(M_new,2), P)/(2.*(Spectral(pow(M_new-h,2), P)-2.*Spectral(pow(M_new,2), P)+Spectral(pow(M_new+h,2), P)))); //finite difference definition of width

	if(isnan(zero.second) || M_new < 2.5 || M_new > 4.5)	//If the result is nan or the mass escaped the region of reasonable
	{
		zero.first = Q(P,Parameters[1][0],Parameters[1][1],Parameters[1][2]);	//Instead, return result based off input parameters, better than garabage
		zero.second = Q(P,Parameters[2][0],Parameters[2][1],Parameters[2][2])*Width(zero.first,P);
	}
}

long double Spectral_Inter::SpatialGeneralKernel(long double s, long double P, long double z)
{
	return(cos(P*z)/(s+pow(P,2)));
}

long double Spectral_Inter::SpatialCutoffKernel(long double s, long double P0, long double z)
{
	return(-((z*(-2.*P0*z*(12852.-5868.*pow(sqrt(s)*z,2)+1737.*pow(sqrt(s)*z,4)-78.*pow(sqrt(s)*z,6)+pow(P0*z,8)+pow(sqrt(s)*z,8)+3.*pow(P0*z,4)*(579.+26.*pow(sqrt(s)*z,2)+2.*pow(sqrt(s)*z,4))+pow(P0,6)*(78.*pow(z,6)+4.*s*pow(z,8))+pow(P0,2)*(5868.*pow(z,2)+2418.*s*pow(z,4)-78.*pow(s,2)*pow(z,6)+4.*pow(s,3)*pow(z,8)))*cos(P0*z)+(-5400.+33948.*pow(sqrt(s)*z,2)-16074.*pow(sqrt(s)*z,4)+2301.*pow(sqrt(s)*z,6)-88.*pow(sqrt(s)*z,8)+pow(P0*z,10)+pow(sqrt(s)*z,10)+pow(P0*z,8)*(84.+5.*pow(sqrt(s)*z,2))+pow(P0*z,6)*(2037.+164.*pow(sqrt(s)*z,2)+10.*pow(sqrt(s)*z,4))+pow(P0*z,4)*(10782.+3975.*pow(sqrt(s)*z,2)-12.*pow(sqrt(s)*z,4)+10.*pow(sqrt(s)*z,6))+pow(P0*z,2)*(27756.-4716.*pow(sqrt(s)*z,2)+4239.*pow(sqrt(s)*z,4)-180.*pow(sqrt(s)*z,6)+5.*pow(sqrt(s)*z,8)))*sin(P0*z)))/(pow(P0*z,12)+6.*pow(P0*z,10)*(15.+pow(sqrt(s)*z,2))+3.*pow(P0*z,8)*(819.+90.*pow(sqrt(s)*z,2)+5.*pow(sqrt(s)*z,4))+pow(-36.+216.*pow(sqrt(s)*z,2)-45.*pow(sqrt(s)*z,4)+pow(sqrt(s)*z,6),2)+4.*pow(P0*z,6)*(4878.+1593.*pow(sqrt(s)*z,2)+45.*pow(sqrt(s)*z,4)+5.*pow(sqrt(s)*z,6))+3.*pow(P0*z,4)*(16632.+6120.*pow(sqrt(s)*z,2)+2610.*pow(sqrt(s)*z,4)-60.*pow(sqrt(s)*z,6)+5.*pow(sqrt(s)*z,8))+6.*pow(P0*z,2)*(2592.+12312.*pow(sqrt(s)*z,2)-3060.*pow(sqrt(s)*z,4)+1062.*pow(sqrt(s)*z,6)-45.*pow(sqrt(s)*z,8)+pow(sqrt(s)*z,10)))));
}

long double Spectral_Inter::SpatialLorentzKernel(long double s, long double z)
{
	return(M_PI/(2.*sqrt(s))*exp(-sqrt(s)*z));
}

long double Spectral_Inter::EuclideanKernel(long double s, long double P, long double tau, long double T)
{
	return(cosh(sqrt(s+pow(P,2))*(tau-1./(2.*T)))/(2.*sqrt(s+pow(P,2))*sinh(sqrt(s+pow(P,2))/(2.*T))));
}

void Spectral_Inter::Print(ostream& Stream)
{
	for(int i = 0; i < 5; i++)
		for(int j = 1; j < 3; j++)
		{
			Stream << Parameters[i][j];
			if(!(i == 4 && j == 2))
				Stream << ",";
		}
	Stream << flush;
}

void Spectral_Inter::Add(long double Value, int i)		//Add to a parameter
{
	Parameters[i/3][i%3] += Value;
}

void Spectral_Inter::Add(long double Value, int i, int j)
{
	Parameters[i][j] += Value;
}

void Spectral_Inter::Replace(long double Value, int i)	//Replace a parameter outright
{
	Parameters[i/3][i%3] = Value;
}

void Spectral_Inter::Replace(long double Value, int i, int j)
{
	Parameters[i][j] = Value;
}

long double Spectral_Inter::Read(int i)			//Read a parameter
{
	return(Parameters[i/3][i%3]);
}

long double Spectral_Inter::Read(int i, int j)
{
	return(Parameters[i][j]);
}

void Spectral_Inter::mergeSort(long double List[], int a, int b)
{
	int i, j, k;
	long double Temp[(a+b)/2-a+1];

	if(b-a > 1)	//Divide...
	{
		mergeSort(List, a, (a+b)/2);
		mergeSort(List, (a+b)/2+1, b);
	}

	for(i = 0; i <= (a+b)/2-a; i++)	//Copy out the lower half array in prep for copy over
		Temp[i] = List[i+a];

	j = 0;
	k = (a+b)/2+1;
	for(i = a; i <= b && j <= (a+b)/2-a && k <= b; i++)	//... and conqure while both half lists have not been exhausted
	{
		if(Temp[j] <= List[k])
		{
			List[i] = Temp[j];
			j++;
		}
		else
		{
			List[i] = List[k];
			k++;
		}
	}
	for(; i <= b && j <= (a+b)/2-a; i++)	//If the Temp list has not been exhausted, complete the job
	{
		List[i] = Temp[j];
		j++;
	}

	return;
}

void Spectral_Inter::Random(int i, long double Range0[2], long double Range1[2], bool uni_norm)
{
	if(uni_norm)
	{
		Uniform(i, 1, Range0[0], Range0[1]);	//Replace parameter with uniform random between Range0[0] and Range0[1]
		Uniform(i, 2, Range1[0], Range1[1]);	//Replace parameter with uniform random between Range1[0] and Range1[1]
	}
	else
	{
		Normal(i, Range0, Range1);	//Replace parameters with normal random between Rangei[0] and Rangei[1], normal is .1 wide and centered on current value.
	}

	return;
}

void Spectral_Inter::Normal(int i, long double Range0[2], long double Range1[2])	//Box-Muller transform from uniform random to normal random
{
	long double uniform[2] = {Uniform(),Uniform()};
	long double normal[2] = {sqrt(-2.*log(uniform[0]))*cos(2.*M_PI*uniform[1]),sqrt(-2.*log(uniform[0]))*sin(2.*M_PI*uniform[1])};
	long double mu[2] = {Parameters[i][1], Parameters[i][2]};
	long double test[2] = {mu[0]+.1*normal[0],mu[1]+.1*normal[1]};

	while(test[0] < Range0[0] || test[0] > Range0[1] || test[1] < Range1[0] || test[1] > Range1[1])	//Repeat until within given range
	{
		uniform[0] = Uniform();
		uniform[1] = Uniform();
		normal[0] = sqrt(-2.*log(uniform[0]))*cos(2.*M_PI*uniform[1]);
		normal[1] = sqrt(-2.*log(uniform[0]))*sin(2.*M_PI*uniform[1]);
		test[0] = mu[0]+.1*normal[0];
		test[1] = mu[1]+.1*normal[1];
	}

	Parameters[i][1] = test[0];
	Parameters[i][2] = test[1];
}

void Spectral_Inter::Uniform(int i, int j, long double a, long double b)	//uniform random between a and b
{
	Parameters[i][j] = Uniform()*(b-a)+a;
}

long double Spectral_Inter::Uniform()	//uniform random between 0 and 1. Numerical Recipes says to not use std::rand(). Monte-Carlo requires rand() to not autocorralate. std::rand() auto-corralates. This is a minimization algorithm, this is fine. As of C++11 (2011), C++ includes standard algorithm libraries that includes high qualilty RGN. You should probably use one of those instead.
{
	return((long double)(rand())/(long double)(RAND_MAX));
}
#endif
